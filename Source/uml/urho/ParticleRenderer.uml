<?xml version="1.0" encoding="UTF-8"?>
<XPD:PROJECT xmlns:XPD="http://www.staruml.com" version="1">
<XPD:HEADER>
<XPD:SUBUNITS>
</XPD:SUBUNITS>
<XPD:PROFILES>
</XPD:PROFILES>
</XPD:HEADER>
<XPD:BODY>
<XPD:OBJ name="DocumentElement" type="UMLProject" guid="pPjpAS5Gy0GFkchglsAA6wAA">
<XPD:ATTR name="Title" type="string">ParticleRenderer</XPD:ATTR>
<XPD:ATTR name="#OwnedElements" type="integer">1</XPD:ATTR>
<XPD:OBJ name="OwnedElements[0]" type="UMLModel" guid="fz9G1JBPSUSkW7llxgnQRQAA">
<XPD:ATTR name="Name" type="string">ParticleRenderer</XPD:ATTR>
<XPD:ATTR name="InnerName" type="string">ParticleRenderer</XPD:ATTR>
<XPD:REF name="Namespace">pPjpAS5Gy0GFkchglsAA6wAA</XPD:REF>
<XPD:ATTR name="#OwnedDiagrams" type="integer">1</XPD:ATTR>
<XPD:OBJ name="OwnedDiagrams[0]" type="UMLClassDiagram" guid="Q+AhfzwKP0KuhUYatGRclgAA">
<XPD:ATTR name="Name" type="string">ParticleRenderer</XPD:ATTR>
<XPD:REF name="DiagramOwner">fz9G1JBPSUSkW7llxgnQRQAA</XPD:REF>
<XPD:OBJ name="DiagramView" type="UMLClassDiagramView" guid="0+9K+aLOskqI42ILpjooAgAA">
<XPD:REF name="Diagram">Q+AhfzwKP0KuhUYatGRclgAA</XPD:REF>
<XPD:ATTR name="#OwnedViews" type="integer">21</XPD:ATTR>
<XPD:OBJ name="OwnedViews[0]" type="UMLNoteView" guid="MfpCy7v4AkCLSD6uhbHy4QAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Left" type="integer">164</XPD:ATTR>
<XPD:ATTR name="Top" type="integer">860</XPD:ATTR>
<XPD:ATTR name="Width" type="integer">1058</XPD:ATTR>
<XPD:ATTR name="Height" type="integer">608</XPD:ATTR>
<XPD:ATTR name="Text" type="string">void ParticleRenderer::UVInfo::setMaterialUVTransform(const Vector2&amp; offset, float rotation, const Vector2&amp; repeat, Material* material, const String&amp; uName /*= &quot;UOffset&quot;*/, const String&amp; vName /*= &quot;VOffset&quot;*/)
{
        Matrix3x4 transform(Matrix3x4::IDENTITY);
        CoreUtil::toUVTransform(transform,
                offset, rotation, repeat);

        material-&gt;setShaderParameter(uName, Vector4(transform[0][0], transform[0][1], transform[0][2], transform[0][3]));
        material-&gt;setShaderParameter(vName, Vector4(transform[1][0], transform[1][1], transform[1][2], transform[1][3]));
}

void ParticleRenderer::UVInfo::setMaterialUVTransform(Material* material, const String&amp; uName /*= &quot;UOffset&quot;*/, const String&amp; vName /*= &quot;VOffset&quot;*/)
{
        setMaterialUVTransform(mUVOffset, mUVRotation, mUVRepeat, material, uName, vName);
}
void ParticleRenderer::UVInfo::setMaterialUVTransformWithAnim(Material* material, const String&amp; uName /*= &quot;UOffset&quot;*/, const String&amp; vName /*= &quot;VOffset&quot;*/)
{
        setMaterialUVTransform(mUVOffset + mUVAnimOffset, mUVRotation, mUVRepeat, material, uName, vName);
}
void ParticleRenderer::UVInfo::setGraphicsUVTransform(const Vector2&amp; offset, float rotation, const Vector2&amp; repeat, Graphics* graphics, const String&amp; uName /*= &quot;UOffset&quot;*/, const String&amp; vName /*= &quot;VOffset&quot;*/)
{
        Matrix3x4 transform(Matrix3x4::IDENTITY);
        CoreUtil::toUVTransform(transform,
                offset, rotation, repeat);

        graphics-&gt;setShaderParameter(uName, Vector4(transform[0][0], transform[0][1], transform[0][2], transform[0][3]));
        graphics-&gt;setShaderParameter(vName, Vector4(transform[1][0], transform[1][1], transform[1][2], transform[1][3]));
}

void ParticleRenderer::UVInfo::setGraphicsUVTransform(Graphics* graphics, const String&amp; uName /*= &quot;UOffset&quot;*/, const String&amp; vName /*= &quot;VOffset&quot;*/)
{
        setGraphicsUVTransform(mUVOffset, mUVRotation, mUVRepeat, graphics, uName, vName);
}
void ParticleRenderer::UVInfo::setGraphicsUVTransformWithAnim(Graphics* graphics, const String&amp; uName /*= &quot;UOffset&quot;*/, const String&amp; vName /*= &quot;VOffset&quot;*/)
{
        setGraphicsUVTransform(mUVOffset + mUVAnimOffset, mUVRotation, mUVRepeat, graphics, uName, vName);
}


// UVInfo 的主要作用有两个，一个是把 offset,rotation repeat 转换为一个矩阵，然后把矩阵的第一行和第二行分别赋值给 Material 的 &quot;UOffset&quot;  和 &quot;VOffset&quot; 属性
// 另一个作用是 把 mUAddressMode 和 mVAddressMode 赋值为 漫反射纹理 的寻址模式
</XPD:ATTR>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[1]" type="UMLNoteView" guid="Yw3AByvCjEqfVY/phqHwvwAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Left" type="integer">392</XPD:ATTR>
<XPD:ATTR name="Top" type="integer">1552</XPD:ATTR>
<XPD:ATTR name="Width" type="integer">586</XPD:ATTR>
<XPD:ATTR name="Height" type="integer">938</XPD:ATTR>
<XPD:ATTR name="Text" type="string">***************************************************
///漫反射uv信息
UVInfo                        mDiffuseUVInfo;
***************************************************
//更新材质
void ParticleRenderer::updateMaterial()
{
       ..................
        mDiffuseUVInfo.setMaterialUVTransform(mMaterial);
       ....................
}
// 根据  mDiffuseUVInfo 已经设置的属性，设置Material 的 &quot;UOffset&quot;  和 &quot;VOffset&quot; 属性

-----------------------------------------------------------------------------------------------------------------------
///更新纹理
void ParticleRenderer::updateTexture()
{
       ..............................
        if (mTexture)
        {
                ........................
                mTexture-&gt;setBorderColor(Color(0.0f, 0.0f, 0.0f, 0.0f));
                mTexture-&gt;setAddressMode(COORD_U, (TextureAddressMode)mDiffuseUVInfo.mUAddressMode);
                mTexture-&gt;setAddressMode(COORD_V, (TextureAddressMode)mDiffuseUVInfo.mVAddressMode);
        }
}

-----------------------------------------------------------------------------------------------------------------------
//设置寻址模式
void ParticleRenderer::setUAddressMode(unsigned mode)
{
        mDiffuseUVInfo.mUAddressMode = mode;
        if(mTexture)
                mTexture-&gt;setAddressMode(COORD_U, (TextureAddressMode)mDiffuseUVInfo.mUAddressMode);
}
void ParticleRenderer::setVAddressMode(unsigned mode)
{
        mDiffuseUVInfo.mVAddressMode = mode;
        if (mTexture)
                mTexture-&gt;setAddressMode(COORD_V, (TextureAddressMode)mDiffuseUVInfo.mVAddressMode);
}
// 用 mDiffuseUVInfo.mUAddressMode  mDiffuseUVInfo.mVAddressMode设置漫反射纹理的 UV寻址模式

----------------------------------------------------------------------------------------------------------------------------
//更新后
void ParticleRenderer::postUpdate(float timeElapsed)
{
                .............................
        if (mDiffuseUVInfo.mUVAnimEnabled)
        {
                float speed = mDynamicAttributeHelper.calculate(mDynDiffuseUVSpeed, timeFraction).getFloat();
                mDiffuseUVInfo.mUVAnimOffset += mDiffuseUVInfo.mUVAnimSpeed * timeElapsed * speed;
        }
                ..................................
        if (isUVAnimEnabled())
        {
                mDiffuseUVInfo.setMaterialUVTransformWithAnim(mMaterial);
        }
                .................................
}
// 在update函数过后，设置 mDiffuseUVInfo.mUVAnimOffset属性，并且更新mDiffuseUVInfo的矩阵
// 重新设置 Material 的 &quot;UOffset&quot;  和 &quot;VOffset&quot; 属性
</XPD:ATTR>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[2]" type="UMLNoteView" guid="g8mCwxnbsUC6G1kpZ3NTAgAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Left" type="integer">276</XPD:ATTR>
<XPD:ATTR name="Top" type="integer">152</XPD:ATTR>
<XPD:ATTR name="Width" type="integer">834</XPD:ATTR>
<XPD:ATTR name="Height" type="integer">548</XPD:ATTR>
<XPD:ATTR name="Text" type="string">struct UVInfo
{
        ///uv动画
        bool                  mUVAnimEnabled;
        Vector2             mUVAnimOffset;
        Vector2             mUVAnimSpeed;
        ///uv变换
        Vector2             mUVOffset;
        float                  mUVRotation;
        Vector2             mUVRepeat;
        ///寻址模式
        unsigned            mUAddressMode;
        unsigned            mVAddressMode;
}


  &lt;Group name=&quot;漫反射纹理&quot;&gt;
    &lt;Property name=&quot;资源&quot; data=&quot;effect/unpack;false&quot; desc=&quot;&quot; vType=&quot;Texture&quot; propertyID=&quot;tex_name&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;U寻址&quot; data=&quot;平铺;镜像;限制;单张;&quot; desc=&quot;&quot; vType=&quot;Enum&quot; propertyID=&quot;u_address_mode&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;V寻址&quot; data=&quot;平铺;镜像;限制;单张;&quot; desc=&quot;&quot; vType=&quot;Enum&quot; propertyID=&quot;v_address_mode&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;偏移&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;Vector2&quot; propertyID=&quot;uv_offset&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;旋转&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;Double&quot; propertyID=&quot;uv_rotation&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;平铺&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;Vector2&quot; propertyID=&quot;uv_repeat&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;动画启用&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;Bool&quot; propertyID=&quot;uv_anim_enabled&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;动画方向&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;Vector2&quot; propertyID=&quot;uv_anim_speed&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;动画速度&quot; data=&quot;0;10;Float&quot; desc=&quot;&quot; vType=&quot;DynamicAttribute&quot; propertyID=&quot;uv_anim_global_speed&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
  &lt;/Group&gt;
</XPD:ATTR>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[3]" type="UMLNoteLinkView" guid="v92E0qgnL0mr8Ydkhl8P2gAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Points" type="Points">692,860;692,699</XPD:ATTR>
<XPD:REF name="Head">g8mCwxnbsUC6G1kpZ3NTAgAA</XPD:REF>
<XPD:REF name="Tail">MfpCy7v4AkCLSD6uhbHy4QAA</XPD:REF>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[4]" type="UMLNoteLinkView" guid="kiqFrS/9qUODcQse1MM3zAAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Points" type="Points">688,1552;689,1467</XPD:ATTR>
<XPD:REF name="Head">MfpCy7v4AkCLSD6uhbHy4QAA</XPD:REF>
<XPD:REF name="Tail">Yw3AByvCjEqfVY/phqHwvwAA</XPD:REF>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[5]" type="UMLNoteView" guid="Jb4qIv1y3Ui/ZAP1pD7jjQAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Left" type="integer">1772</XPD:ATTR>
<XPD:ATTR name="Top" type="integer">1648</XPD:ATTR>
<XPD:ATTR name="Width" type="integer">658</XPD:ATTR>
<XPD:ATTR name="Height" type="integer">1733</XPD:ATTR>
<XPD:ATTR name="Text" type="string">*************************************************
///多层溶解
Vector&lt;DissolveInfo&gt;        mDissolveInfos;
ColorLine                             mDissolveColor;
float                                    mDissolveColorSize;
UVInfo                                 mDissolveUVInfo;
*************************************************
//更新材质
void ParticleRenderer::updateMaterial()
{
       ........................
        if (isDissolveEnabled(0))
        {
                mDissolveUVInfo.setMaterialUVTransform(mMaterial, DISSOLVE_UNAME, DISSOLVE_VNAME);
        }
        ........................
}
// 根据  mDissolveUVInfo 已经设置的属性，设置Material 的 &quot;DissolveUOffset&quot;  和 &quot;DissolveVOffset&quot; 属性

---------------------------------------------------------------------------------------------------------------------------------

void ParticleRenderer::_notifyStart(void)
{

        Vector&lt;DissolveInfo&gt;::Iterator i, iend = mDissolveInfos.end();
        for (i = mDissolveInfos.begin(); i != iend; ++i)
        {
                DissolveInfo&amp; info = *i;
                if (info.textureDirty &amp;&amp; info.enabled)
                {
                        ResourceCache* cache = mContext-&gt;getSubsystem&lt;ResourceCache&gt;();
                        if (!info.textureName.empty())
                                info.texture = cache-&gt;getResource&lt;Texture2D&gt;(info.textureName, true, Texture::CLOSE_MINMAP_PARAMS);
                        if (info.texture)
                        {
                                info.texture-&gt;setBorderColor(Color(0.0f, 0.0f, 0.0f, 0.0f));
                                info.texture-&gt;setAddressMode(COORD_U, (TextureAddressMode)mDissolveUVInfo.mUAddressMode);
                                info.texture-&gt;setAddressMode(COORD_V, (TextureAddressMode)mDissolveUVInfo.mVAddressMode);
                        }
                        info.textureDirty = false;
                }
        }
}
// 用 mDissolveUVInfo.mUAddressMode  mDissolveUVInfo.mVAddressMode设置DissolveInfo相关纹理的 UV寻址模式

------------------------------------------------------------------------------------------------------------------------------------------

void ParticleRenderer::postUpdate(float timeElapsed)
{
        float timeFraction = getTimeFraction();

        if (isDissolveUVAnimEnabled())
        {
                mDissolveUVInfo.mUVAnimOffset += mDissolveUVInfo.mUVAnimSpeed * timeElapsed;
        }

        if (isDissolveEnabled(0) &amp;&amp; mFirstTotalTimeToLiveSet)
        {
                //更新shader参数
                for (unsigned index = 0; index &lt; mDissolveInfos.size(); ++index)
                {
                        DissolveInfo&amp; info = mDissolveInfos[index];
                        float DissolveFactor = mDynamicAttributeHelper.calculate(info.time, timeFraction).getFloat();
                        mMaterial-&gt;setShaderParameter(DISSOLVE_FACTOR[index], DissolveFactor);
                }
                Color DissolveColor = mDissolveColor._calculate(timeFraction);
                mMaterial-&gt;setShaderParameter(&quot;DissolveColor&quot;, DissolveColor);
                mMaterial-&gt;setShaderParameter(&quot;DissolveColorSize&quot;, mDissolveColorSize);
        }

        if (isDissolveUVAnimEnabled())
        {
                mDissolveUVInfo.setMaterialUVTransformWithAnim(mMaterial, DISSOLVE_UNAME, DISSOLVE_VNAME);
        }
}

// 设置  mDissolveUVInfo.mUVAnimOffset
// 使用  DissolveInfo.time 计算出一个系数，设置  Material 的 &quot;DissolveFactor0&quot;  和 ”DissolveFactor1“属性
// 根据  mDissolveUVInfo 已经设置的属性,更新矩阵，设置Material 的 &quot;DissolveUOffset&quot;  和 &quot;DissolveVOffset&quot; 属性
------------------------------------------------------------------------------------------------------------------------------------------

///设置寻址模式
void ParticleRenderer::setDissolveUAddressMode(unsigned mode)
{
        mDissolveUVInfo.mUAddressMode = mode;
        for (unsigned index = 0; index &lt; mDissolveInfos.size(); ++index)
        {
                DissolveInfo&amp; info = mDissolveInfos[index];
                if(info.enabled &amp;&amp; info.texture)
                        info.texture-&gt;setAddressMode(COORD_U, (TextureAddressMode)mDissolveUVInfo.mUAddressMode);
        }
}

void ParticleRenderer::setDissolveVAddressMode(unsigned mode)
{
        mDissolveUVInfo.mVAddressMode = mode;
        for (unsigned index = 0; index &lt; mDissolveInfos.size(); ++index)
        {
                DissolveInfo&amp; info = mDissolveInfos[index];
                if (info.enabled &amp;&amp; info.texture)
                        info.texture-&gt;setAddressMode(COORD_V, (TextureAddressMode)mDissolveUVInfo.mVAddressMode);
        }
}
// 用 mDissolveUVInfo.mUAddressMode  mDissolveUVInfo.mVAddressMode设置DissolveInfo相关纹理的 UV寻址模式
----------------------------------------------------------------------------------------------------------------------------------------------
///绑定所有溶解纹理
void ParticleRenderer::bindAllDissolveTexture(Material* mat)
{
        if (isDissolveEnabled(0))
                mat-&gt;setTexture(TU_ENVIRONMENT, getDissolveTexture(0));
        if (isDissolveEnabled(1))
                mat-&gt;setTexture(TU_DISSOLVE, getDissolveTexture(1));
}
//  mDissolveUVInfo 的大部分属性最终作用于  mDissolveInfos中的两个纹理，当启用溶解的时候， mDissolveInfos中的纹理
//  会被设置为Material 的 TU_ENVIRONMENT 和 TU_DISSOLVE 级纹理
</XPD:ATTR>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[6]" type="UMLNoteView" guid="094zBomoJ0Wlk+btXAEHOwAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Left" type="integer">1676</XPD:ATTR>
<XPD:ATTR name="Top" type="integer">44</XPD:ATTR>
<XPD:ATTR name="Width" type="integer">839</XPD:ATTR>
<XPD:ATTR name="Height" type="integer">653</XPD:ATTR>
<XPD:ATTR name="Text" type="string">struct UVInfo
{
        ///uv动画
        bool                  mUVAnimEnabled;
        Vector2             mUVAnimOffset;
        Vector2             mUVAnimSpeed;
        ///uv变换
        Vector2             mUVOffset;
        float                  mUVRotation;
        Vector2             mUVRepeat;
        ///寻址模式
        unsigned            mUAddressMode;
        unsigned            mVAddressMode;
}

///溶解结构
struct DissolveInfo
{
        bool                                        enabled;
        SharedPtr&lt;DynamicAttribute&gt;        time;
        String                                        textureName;
        SharedPtr&lt;Texture2D&gt;        texture;
        bool                                        textureDirty;
};

&lt;Group name=&quot;溶解配置&quot;&gt;
    &lt;Property name=&quot;燃烧颜色&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;TimeColor&quot; propertyID=&quot;dissolve_color&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;燃烧颜色宽度&quot; data=&quot;0;0.2;Float&quot; desc=&quot;&quot; vType=&quot;Double&quot; propertyID=&quot;dissolve_color_size&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;U寻址&quot; data=&quot;平铺;镜像;限制;单张;&quot; desc=&quot;&quot; vType=&quot;Enum&quot; propertyID=&quot;dissolve_u_address_mode&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;V寻址&quot; data=&quot;平铺;镜像;限制;单张;&quot; desc=&quot;&quot; vType=&quot;Enum&quot; propertyID=&quot;dissolve_v_address_mode&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;偏移&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;Vector2&quot; propertyID=&quot;dissolve_uv_offset&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;旋转&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;Double&quot; propertyID=&quot;dissolve_uv_rotation&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;平铺&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;Vector2&quot; propertyID=&quot;dissolve_uv_repeat&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;动画启用&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;Bool&quot; propertyID=&quot;dissolve_uv_anim_enabled&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;动画速度&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;Vector2&quot; propertyID=&quot;dissolve_uv_anim_speed&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
  &lt;/Group&gt;

&lt;Group name=&quot;溶解纹理&quot;&gt;
    &lt;Property name=&quot;溶解1&quot; data=&quot;0;10;Float&quot; desc=&quot;&quot; vType=&quot;DynamicAttribute&quot; propertyID=&quot;dissolve&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;溶解资源1&quot; data=&quot;effect/unpack&quot; desc=&quot;&quot; vType=&quot;Texture&quot; propertyID=&quot;dissolve_tex_name&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;溶解2&quot; data=&quot;0;10;Float&quot; desc=&quot;&quot; vType=&quot;DynamicAttribute&quot; propertyID=&quot;dissolve2&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;溶解资源2&quot; data=&quot;effect/unpack&quot; desc=&quot;&quot; vType=&quot;Texture&quot; propertyID=&quot;dissolve2_tex_name&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
  &lt;/Group&gt;
</XPD:ATTR>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[7]" type="UMLNoteView" guid="I/tRW6oXO0aIK/GAAzbDYQAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Left" type="integer">1568</XPD:ATTR>
<XPD:ATTR name="Top" type="integer">884</XPD:ATTR>
<XPD:ATTR name="Width" type="integer">1058</XPD:ATTR>
<XPD:ATTR name="Height" type="integer">608</XPD:ATTR>
<XPD:ATTR name="Text" type="string">void ParticleRenderer::UVInfo::setMaterialUVTransform(const Vector2&amp; offset, float rotation, const Vector2&amp; repeat, Material* material, const String&amp; uName /*= &quot;UOffset&quot;*/, const String&amp; vName /*= &quot;VOffset&quot;*/)
{
        Matrix3x4 transform(Matrix3x4::IDENTITY);
        CoreUtil::toUVTransform(transform,
                offset, rotation, repeat);

        material-&gt;setShaderParameter(uName, Vector4(transform[0][0], transform[0][1], transform[0][2], transform[0][3]));
        material-&gt;setShaderParameter(vName, Vector4(transform[1][0], transform[1][1], transform[1][2], transform[1][3]));
}

void ParticleRenderer::UVInfo::setMaterialUVTransform(Material* material, const String&amp; uName /*= &quot;UOffset&quot;*/, const String&amp; vName /*= &quot;VOffset&quot;*/)
{
        setMaterialUVTransform(mUVOffset, mUVRotation, mUVRepeat, material, uName, vName);
}
void ParticleRenderer::UVInfo::setMaterialUVTransformWithAnim(Material* material, const String&amp; uName /*= &quot;UOffset&quot;*/, const String&amp; vName /*= &quot;VOffset&quot;*/)
{
        setMaterialUVTransform(mUVOffset + mUVAnimOffset, mUVRotation, mUVRepeat, material, uName, vName);
}
void ParticleRenderer::UVInfo::setGraphicsUVTransform(const Vector2&amp; offset, float rotation, const Vector2&amp; repeat, Graphics* graphics, const String&amp; uName /*= &quot;UOffset&quot;*/, const String&amp; vName /*= &quot;VOffset&quot;*/)
{
        Matrix3x4 transform(Matrix3x4::IDENTITY);
        CoreUtil::toUVTransform(transform,
                offset, rotation, repeat);

        graphics-&gt;setShaderParameter(uName, Vector4(transform[0][0], transform[0][1], transform[0][2], transform[0][3]));
        graphics-&gt;setShaderParameter(vName, Vector4(transform[1][0], transform[1][1], transform[1][2], transform[1][3]));
}

void ParticleRenderer::UVInfo::setGraphicsUVTransform(Graphics* graphics, const String&amp; uName /*= &quot;UOffset&quot;*/, const String&amp; vName /*= &quot;VOffset&quot;*/)
{
        setGraphicsUVTransform(mUVOffset, mUVRotation, mUVRepeat, graphics, uName, vName);
}
void ParticleRenderer::UVInfo::setGraphicsUVTransformWithAnim(Graphics* graphics, const String&amp; uName /*= &quot;UOffset&quot;*/, const String&amp; vName /*= &quot;VOffset&quot;*/)
{
        setGraphicsUVTransform(mUVOffset + mUVAnimOffset, mUVRotation, mUVRepeat, graphics, uName, vName);
}


// UVInfo 的主要作用有两个，一个是把 offset,rotation repeat 转换为一个矩阵，然后把矩阵的第一行和第二行分别赋值给 Material 的 &quot;UOffset&quot;  和 &quot;VOffset&quot; 属性
// 另一个作用是 把 mUAddressMode 和 mVAddressMode 赋值为 漫反射纹理 的寻址模式
</XPD:ATTR>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[8]" type="UMLNoteLinkView" guid="Y7pMoyyjSEOKfoJfaYIUVQAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Points" type="Points">2096,884;2096,696</XPD:ATTR>
<XPD:REF name="Head">094zBomoJ0Wlk+btXAEHOwAA</XPD:REF>
<XPD:REF name="Tail">I/tRW6oXO0aIK/GAAzbDYQAA</XPD:REF>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[9]" type="UMLNoteLinkView" guid="CmPTIMnZS0icKsOpXayuoAAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Points" type="Points">2097,1648;2097,1491</XPD:ATTR>
<XPD:REF name="Head">I/tRW6oXO0aIK/GAAzbDYQAA</XPD:REF>
<XPD:REF name="Tail">Jb4qIv1y3Ui/ZAP1pD7jjQAA</XPD:REF>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[10]" type="UMLNoteView" guid="G1SJiuDXmEqCF9xSzj6MJwAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Left" type="integer">3224</XPD:ATTR>
<XPD:ATTR name="Top" type="integer">108</XPD:ATTR>
<XPD:ATTR name="Width" type="integer">822</XPD:ATTR>
<XPD:ATTR name="Height" type="integer">548</XPD:ATTR>
<XPD:ATTR name="Text" type="string">///纹理动画类型
enum TextureAnimationType
{
        TAT_LOOP,
        TAT_UP_DOWN,
        TAT_RANDOM,
        TAT_ONCE,
};

///纹理动画结构
struct LYEFFECT_API TextureAnimation
{
        bool enabled;
        float animationTimeStep;
        float animationTimeStepCount;
        bool startRandom;
        uint16 randomStart;
        uint16 randomEnd;
        bool nextIndex;
        unsigned type;
        uint16 textureCoordsStart;
        uint16 textureCoordsEnd;
        void _determineNextTextureCoords(ParticleRenderer* renderer, uint16&amp; textureCoordsCurrent, bool&amp; textureAnimationDirectionUp);
};


  &lt;Group name=&quot;逐帧动画&quot;&gt;
    &lt;Property name=&quot;启用&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;Bool&quot; propertyID=&quot;texture_animation_enabled&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;类型&quot; data=&quot;循环;上下;随机;单次;&quot; desc=&quot;&quot; vType=&quot;Enum&quot; propertyID=&quot;texture_animation_type&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;时间步进&quot; data=&quot;4&quot; desc=&quot;&quot; vType=&quot;Double&quot; propertyID=&quot;texture_animation_time_step&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;开始随机&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;Bool&quot; propertyID=&quot;texture_animation_start_random&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;随机开始帧&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;Int&quot; propertyID=&quot;texture_animation_random_start&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;随机结束帧&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;Int&quot; propertyID=&quot;texture_animation_random_end&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;切割行&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;Int&quot; propertyID=&quot;tex_split_row&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;切割列&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;Int&quot; propertyID=&quot;tex_split_col&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
  &lt;/Group&gt;
</XPD:ATTR>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[11]" type="UMLNoteView" guid="wQzLuSWXu0qCa1rgrzGY4wAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Left" type="integer">3212</XPD:ATTR>
<XPD:ATTR name="Top" type="integer">808</XPD:ATTR>
<XPD:ATTR name="Width" type="integer">841</XPD:ATTR>
<XPD:ATTR name="Height" type="integer">908</XPD:ATTR>
<XPD:ATTR name="Text" type="string">void ParticleRenderer::TextureAnimation::_determineNextTextureCoords(ParticleRenderer* renderer, uint16&amp; textureCoordsCurrent, bool&amp; textureAnimationDirectionUp)
{
        switch (type)
        {
        case TAT_LOOP:
        {
                if (textureCoordsCurrent &gt;= textureCoordsEnd)
                {
                        textureCoordsCurrent = textureCoordsStart;
                }
                else
                {
                        (textureCoordsCurrent)++;
                }
        }
        break;
        case TAT_ONCE:
        {
                (textureCoordsCurrent)++;
        }
        break;

        case TAT_UP_DOWN:
        {
                if (textureAnimationDirectionUp == true)
                {
                        if (textureCoordsCurrent &gt;= textureCoordsEnd)
                        {
                                (textureCoordsCurrent)--;
                                textureAnimationDirectionUp = false;
                        }
                        else
                        {
                                (textureCoordsCurrent)++;
                        }
                }
                else
                {
                        if (textureCoordsCurrent &lt;= textureCoordsStart)
                        {
                                (textureCoordsCurrent)++;
                                textureAnimationDirectionUp = true;
                        }
                        else
                        {
                                (textureCoordsCurrent)--;
                        }
                }
        }
        break;

        case TAT_RANDOM:
        {
                textureCoordsCurrent = (uint16)renderer-&gt;getParticleSystem()-&gt;getRangeRandom((float)textureCoordsStart, (float)textureCoordsEnd + 0.999f);
        }
        break;
        }
}

// 根据type类型和已有的TextureAnimation属性，计算ParticleVisual 的 textureCoordsCurrent
</XPD:ATTR>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[12]" type="UMLNoteLinkView" guid="fit1z6OwgEaqZw4BebJRhAAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Points" type="Points">3633,808;3633,655</XPD:ATTR>
<XPD:REF name="Head">G1SJiuDXmEqCF9xSzj6MJwAA</XPD:REF>
<XPD:REF name="Tail">wQzLuSWXu0qCa1rgrzGY4wAA</XPD:REF>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[13]" type="UMLNoteView" guid="KMTF/z2CpUye8nHCuTwv5wAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Left" type="integer">3256</XPD:ATTR>
<XPD:ATTR name="Top" type="integer">1904</XPD:ATTR>
<XPD:ATTR name="Width" type="integer">756</XPD:ATTR>
<XPD:ATTR name="Height" type="integer">1193</XPD:ATTR>
<XPD:ATTR name="Text" type="string">******************************************************
TextureAnimation        mTextureAnimation;
******************************************************
void ParticleRenderer::_notifyStart(void)
{
        ......................................
        //初始化序列帧动画值
        if (mTextureAnimation.enabled)
        {
                mTextureAnimation.textureCoordsStart = 0;
                mTextureAnimation.textureCoordsEnd = getNumImagesets() - 1;
        }
}
// 初始化的时候 设置  mTextureAnimation.textureCoordsStart 和  mTextureAnimation.textureCoordsEnd
--------------------------------------------------------------------------------------------------------------------------------------------

//更新序列动画
void ParticleRenderer::updateTextureAnimation(Particle* particle)
{
        //更新序列动画
        if (mTextureAnimation.enabled &amp;&amp; particle-&gt;particleType == Particle::PT_VISUAL)
        {
                ParticleVisual* visualParticle = static_cast&lt;ParticleVisual*&gt;(particle);

                if (mTextureAnimation.nextIndex)
                {
                        mTextureAnimation._determineNextTextureCoords(this, visualParticle-&gt;textureCoordsCurrent,
                                visualParticle-&gt;textureAnimationDirectionUp);
                }
        }
}
// 如果 mTextureAnimation.nextIndex 为 true 。计算 ParticleVisual.textureCoordsCurrent
--------------------------------------------------------------------------------------------------------------------------------------------

//准备处理粒子
void ParticleRenderer::_preProcessParticles(ParticleTechnique* particleTechnique, float timeElapsed)
{
        if (mTextureAnimation.enabled)
        {
                mTextureAnimation.nextIndex = false;
                mTextureAnimation.animationTimeStepCount += timeElapsed;
                if (mTextureAnimation.animationTimeStepCount &gt; mTextureAnimation.animationTimeStep)
                {
                        mTextureAnimation.animationTimeStepCount -= mTextureAnimation.animationTimeStep;
                        mTextureAnimation.nextIndex = true;
                }
        }
}
// 确定   mTextureAnimation.animationTimeStepCount  和  mTextureAnimation.nextIndex，为 updateTextureAnimation作准备
--------------------------------------------------------------------------------------------------------------------------------------------

//发射时
void ParticleRenderer::_initParticleForEmission(Particle* particle)
{
        if (particle-&gt;particleType == Particle::PT_VISUAL &amp;&amp; mTextureAnimation.enabled)
        {
                ParticleVisual* visualParticle = static_cast&lt;ParticleVisual*&gt;(particle);

                if (mTextureAnimation.startRandom)
                {
                        uint16 randomStart = mTextureAnimation.randomStart;
                        uint16 randomEnd = mTextureAnimation.randomEnd;

                        if (randomStart &lt; mTextureAnimation.textureCoordsStart)
                                randomStart = mTextureAnimation.textureCoordsStart;
                        if (randomEnd == 0 || randomEnd &gt; mTextureAnimation.textureCoordsEnd)
                                randomEnd = mTextureAnimation.textureCoordsEnd;
                        if (randomEnd &lt; randomStart)
                                randomEnd = randomStart;

                        visualParticle-&gt;textureCoordsCurrent = (uint16)getParticleSystem()-&gt;getRangeRandom((float)randomStart, (float)randomEnd + 0.999f);
                }
                else
                {
                        visualParticle-&gt;textureCoordsCurrent = mTextureAnimation.textureCoordsStart;
                }
        }
}
//  初始化   visualParticle-&gt;textureCoordsCurrent 注意，是 ParticleVisual的 textureCoordsCurrent
</XPD:ATTR>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[14]" type="UMLNoteLinkView" guid="F9BEo7Qvj0CW51MDT1SU2wAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Points" type="Points">3633,1904;3633,1715</XPD:ATTR>
<XPD:REF name="Head">wQzLuSWXu0qCa1rgrzGY4wAA</XPD:REF>
<XPD:REF name="Tail">KMTF/z2CpUye8nHCuTwv5wAA</XPD:REF>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[15]" type="UMLNoteView" guid="rGFOesKg90GeD4YJrkfOmAAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Left" type="integer">224</XPD:ATTR>
<XPD:ATTR name="Top" type="integer">4036</XPD:ATTR>
<XPD:ATTR name="Width" type="integer">473</XPD:ATTR>
<XPD:ATTR name="Height" type="integer">413</XPD:ATTR>
<XPD:ATTR name="Text" type="string">//处理一个粒子
void ParticleStaticModelRenderer::_processParticle(ParticleTechnique* particleTechnique,
        Particle* particle,
        float timeElapsed,
        bool firstParticle)
{
        ParticleRenderer::_processParticle(particleTechnique, particle, timeElapsed, firstParticle);
        if (mNode &amp;&amp; particle-&gt;particleType == Particle::PT_VISUAL)
        {
                ParticleVisual* visual = static_cast&lt;ParticleVisual*&gt;(particle);
                if (particle-&gt;visualData)
                {
                        //设置位置
                        StaticModelRendererVisualData* visualData = particle-&gt;visualData;
                        visualData-&gt;node-&gt;setWorldPosition(visual-&gt;position);

                        //设置缩放
                        updateVisualScale(visual);

                        //设置旋转
                        visualData-&gt;node-&gt;setRotation(visual-&gt;emitterOrientation);
                        
                        //更新材质动画
                        updateMaterialAnimation(timeElapsed, visual, visualData);
                }
        }
}
</XPD:ATTR>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[16]" type="UMLNoteView" guid="rw52MDerIUOxG25VDvXvIwAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Left" type="integer">964</XPD:ATTR>
<XPD:ATTR name="Top" type="integer">3984</XPD:ATTR>
<XPD:ATTR name="Width" type="integer">607</XPD:ATTR>
<XPD:ATTR name="Height" type="integer">518</XPD:ATTR>
<XPD:ATTR name="Text" type="string">//设置漫反射纹理 和 溶解纹理
void ParticleStaticModelRenderer::_notifyStart(void)
{
        ParticleRenderer::_notifyStart();

        Vector&lt;StaticModelRendererVisualData*&gt;::Iterator i, iend = mActiveVisualDatas.end();
        for (i = mActiveVisualDatas.begin(); i != iend; ++i)
        {
                StaticModelRendererVisualData* data = *i;
                if (mUseRendererResource)
                {
                        //设置漫反射纹理
                        data-&gt;setMaterialTexture(TU_DIFFUSE, getTexture());
                }
                else
                {
                        //设置漫反射纹理
                        data-&gt;setMaterialTexture(TU_DIFFUSE, mOldTextures);
                        for (unsigned index = 0; index &lt; mOldTextures.size(); ++index)
                        {
                                Texture* texture = mOldTextures[index];
                                if (texture)
                                {
                                        texture-&gt;setAddressMode(COORD_U, (TextureAddressMode)mDiffuseUVInfo.mUAddressMode);
                                        texture-&gt;setAddressMode(COORD_V, (TextureAddressMode)mDiffuseUVInfo.mVAddressMode);
                                }
                        }
                }
                //设置溶解纹理
                bindAllDissolveTexture(data);
                setDissolveUAddressMode(mDissolveUVInfo.mUAddressMode);
                setDissolveVAddressMode(mDissolveUVInfo.mVAddressMode);
        }
}
</XPD:ATTR>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[17]" type="UMLNoteView" guid="nbJ31WdqHkqgEAj64vudpAAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Left" type="integer">1772</XPD:ATTR>
<XPD:ATTR name="Top" type="integer">4184</XPD:ATTR>
<XPD:ATTR name="Width" type="integer">489</XPD:ATTR>
<XPD:ATTR name="Height" type="integer">158</XPD:ATTR>
<XPD:ATTR name="Text" type="string">// 设置初始scale
void ParticleStaticModelRenderer::_notifyDefaultDimensions(float width, float height, float depth)
{
        Vector&lt;StaticModelRendererVisualData*&gt;::Iterator i, iend = mActiveVisualDatas.end();
        for (i = mActiveVisualDatas.begin(); i != iend; ++i)
        {
                StaticModelRendererVisualData* data = *i;
                data-&gt;node-&gt;setScale(width / mBoxWidth, height / mBoxHeight, depth / mBoxDepth);
        }
}
</XPD:ATTR>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[18]" type="UMLNoteView" guid="IwtHcDpsb0G4bERIEQwzNgAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Left" type="integer">2520</XPD:ATTR>
<XPD:ATTR name="Top" type="integer">3748</XPD:ATTR>
<XPD:ATTR name="Width" type="integer">607</XPD:ATTR>
<XPD:ATTR name="Height" type="integer">1058</XPD:ATTR>
<XPD:ATTR name="Text" type="string">//更新材质
//设置漫反射纹理 和 漫反射纹理的寻址方式
//设置溶解纹理和溶解纹理的寻址方式
//设置渲染顺序
//设置颜色矩阵 &quot;ColorMatrix&quot;
//设置扰动强度 &quot;NoiseStrength&quot;
//设置辉光 &quot;GlowThreshold&quot;
//设置辉光颜色 &quot;GlowColor&quot;
//设置深度偏移
void ParticleStaticModelRenderer::updateMaterialProperties(StaticModelRendererVisualData* data)
{
        for (unsigned index = 0; index &lt; data-&gt;materials.size(); ++index)
        {
                Material* material = data-&gt;materials[index];
                //设置每个material的技术
                setMaterialTechnique(material);

                if (mUseRendererResource)
                {
                        //设置漫反射纹理
                        material-&gt;setTexture(TU_DIFFUSE, getTexture());
                }
                else
                {
                        for (unsigned p = 0; p &lt; mOldTextures.size(); ++p)
                        {
                                Texture* texture = mOldTextures[p];
                                material-&gt;setTexture(TU_DIFFUSE, texture);
                                if (texture)
                                {
                                        //设置漫反射纹理的寻址方式
                                        texture-&gt;setAddressMode(COORD_U, (TextureAddressMode)mDiffuseUVInfo.mUAddressMode);
                                        texture-&gt;setAddressMode(COORD_V, (TextureAddressMode)mDiffuseUVInfo.mVAddressMode);
                                }
                        }
                }
                //设置溶解纹理和溶解纹理的寻址方式
                ParticleRenderer::bindAllDissolveTexture(material);
                setDissolveUAddressMode(mDissolveUVInfo.mUAddressMode);
                setDissolveVAddressMode(mDissolveUVInfo.mVAddressMode);
                //设置渲染顺序
                material-&gt;setRenderOrder(getDerivedRenderOrder());
                material-&gt;setCullMode((CullMode)mCullMode);

                float timeFraction = getTimeFraction();

                if (isColorMatrixSet())
                {
                        //设置颜色矩阵
                        material-&gt;setShaderParameter(&quot;ColorMatrix&quot;, mColorMatrix.getMatrix());
                }
                if (isNoiseSet())
                {
                        mNoise = mDynamicAttributeHelper.calculate(mDynNoise, timeFraction).getFloat();
                        if (mNoise != 0.0f)
                        {
                                //设置扰动强度
                                material-&gt;setShaderParameter(&quot;NoiseStrength&quot;, mNoise);
                        }
                }
                if (isGlowSet())
                {
                        //设置辉光 和 辉光颜色
                        material-&gt;setShaderParameter(&quot;GlowThreshold&quot;, 1.0f - mGlow);
                        material-&gt;setShaderParameter(&quot;GlowColor&quot;, mGlowColor);
                }
                //设置深度偏移
                material-&gt;setDepthBias(BiasParameters(DEPTH_BIAS_VALUE[getDerivedDepthBiasLevel()], 0.0f));
        }
}
</XPD:ATTR>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[19]" type="UMLNoteView" guid="phbKoOAAtU21eROgwWNFkwAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Left" type="integer">3380</XPD:ATTR>
<XPD:ATTR name="Top" type="integer">3724</XPD:ATTR>
<XPD:ATTR name="Width" type="integer">728</XPD:ATTR>
<XPD:ATTR name="Height" type="integer">1073</XPD:ATTR>
<XPD:ATTR name="Text" type="string">//更新纹理动画
//设置漫反射颜色 &quot;MatDiffColor&quot;
//根据 particle-&gt;textureCoordsCurrent 确定分割纹理
//更新material &quot;UOffset&quot; &quot;VOffset&quot;属性
//更新materail &quot;DissolveUOffset&quot;  &quot;DissolveVOffset&quot;属性
//确定下一个 particle-&gt;textureCoordsCurrent
void ParticleStaticModelRenderer::updateMaterialAnimation(float timeElapsed, ParticleVisual* particle, StaticModelRendererVisualData* data)
{
        for (unsigned index = 0; index &lt; data-&gt;materials.size(); ++index)
        {
                Material* material = data-&gt;materials[index];
                //控制材质颜色
                Effect* effect = getEffect();
                if (effect)
                        material-&gt;setShaderParameter(&quot;MatDiffColor&quot;, (mColor * particle-&gt;color * effect-&gt;getColor()).toVector4());
                else
                        material-&gt;setShaderParameter(&quot;MatDiffColor&quot;, (mColor * particle-&gt;color).toVector4());

                if (mUseRendererResource)
                {
                        const Imagedef* def = getImagedef(particle-&gt;textureCoordsCurrent);
                        if (def)
                        {
                                data-&gt;setVisible(mNode-&gt;isEnabled());
                                //设置纹理变换
                                const Vector4&amp; uv = def-&gt;getUV();
                                Vector2 offset(uv.x, uv.y);
                                Vector2 repeat = Vector2(uv.z - uv.x, uv.w - uv.y) * mDiffuseUVInfo.mUVRepeat;
                                if (isUVAnimEnabled())
                                {
                                        Vector2 re = repeat * mDiffuseUVInfo.mUVAnimOffset;
                                        offset += re;
                                }

                                mDiffuseUVInfo.setMaterialUVTransform(offset + mDiffuseUVInfo.mUVOffset, mDiffuseUVInfo.mUVRotation, repeat, material);
                        }
                        else
                        {
                                data-&gt;setVisible(false);
                        }
                }
                else
                {
                        if (isUVAnimEnabled())
                                mDiffuseUVInfo.setMaterialUVTransformWithAnim(material);
                        else
                                mDiffuseUVInfo.setMaterialUVTransform(material);
                }
                if (isDissolveUVAnimEnabled())
                        mDissolveUVInfo.setMaterialUVTransformWithAnim(material, DISSOLVE_UNAME, DISSOLVE_VNAME);
                else
                        mDissolveUVInfo.setMaterialUVTransform(material, DISSOLVE_UNAME, DISSOLVE_VNAME);
        }
        //更新序列动画 确定下一个particle-&gt;textureCoordsCurrent
        if (mTextureAnimation.enabled)
        {
                data-&gt;textureAnimation.nextIndex = false;
                data-&gt;textureAnimation.animationTimeStepCount += timeElapsed;
                if (data-&gt;textureAnimation.animationTimeStepCount &gt; data-&gt;textureAnimation.animationTimeStep)
                {
                        data-&gt;textureAnimation.animationTimeStepCount -= data-&gt;textureAnimation.animationTimeStep;
                        data-&gt;textureAnimation.nextIndex = true;
                }

                if (data-&gt;textureAnimation.nextIndex)
                {
                        data-&gt;textureAnimation._determineNextTextureCoords(this, particle-&gt;textureCoordsCurrent,
                                particle-&gt;textureAnimationDirectionUp);
                }
        }
}
</XPD:ATTR>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[20]" type="UMLNoteView" guid="45mtfhGrTUmSRx5W0WmITgAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Left" type="integer">4304</XPD:ATTR>
<XPD:ATTR name="Top" type="integer">4008</XPD:ATTR>
<XPD:ATTR name="Width" type="integer">589</XPD:ATTR>
<XPD:ATTR name="Height" type="integer">488</XPD:ATTR>
<XPD:ATTR name="Text" type="string">//更新material 溶解相关shader参数 &quot;DissolveFactor0&quot; &quot;DissolveFactor1&quot; &quot;DissolveColor&quot; &quot;DissolveColorSize&quot;
void ParticleStaticModelRenderer::postUpdate(float timeElapsed)
{
        ParticleRenderer::postUpdate(timeElapsed);
        if (isDissolveEnabled(0))
        {
                Vector&lt;StaticModelRendererVisualData*&gt;::Iterator i, iend = mActiveVisualDatas.end();
                for (i = mActiveVisualDatas.begin(); i != iend; ++i)
                {
                        StaticModelRendererVisualData* data = *i;
                        //更新shader参数
                        float timeFraction = data-&gt;particle-&gt;timeFraction;
                        Color DissolveColor = mDissolveColor._calculate(timeFraction);
                        for (unsigned m = 0; m &lt; data-&gt;materials.size(); ++m)
                        {
                                Material* material = data-&gt;materials[m];

                                for (unsigned index = 0; index &lt; mDissolveInfos.size(); ++index)
                                {
                                        DissolveInfo&amp; info = mDissolveInfos[index];
                                        float DissolveFactor = mDynamicAttributeHelper.calculate(info.time, timeFraction).getFloat();
                                        String factorName = &quot;DissolveFactor&quot;;
                                        factorName.appendWithFormat(&quot;%d&quot;, index);
                                        material-&gt;setShaderParameter(factorName, DissolveFactor);
                                }

                                material-&gt;setShaderParameter(&quot;DissolveColor&quot;, DissolveColor);
                                material-&gt;setShaderParameter(&quot;DissolveColorSize&quot;, mDissolveColorSize);
                        }
                }
        }
}
</XPD:ATTR>
</XPD:OBJ>
</XPD:OBJ>
</XPD:OBJ>
</XPD:OBJ>
</XPD:OBJ>
</XPD:BODY>
</XPD:PROJECT>
