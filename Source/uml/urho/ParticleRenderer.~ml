<?xml version="1.0" encoding="UTF-8"?>
<XPD:PROJECT xmlns:XPD="http://www.staruml.com" version="1">
<XPD:HEADER>
<XPD:SUBUNITS>
</XPD:SUBUNITS>
<XPD:PROFILES>
</XPD:PROFILES>
</XPD:HEADER>
<XPD:BODY>
<XPD:OBJ name="DocumentElement" type="UMLProject" guid="pPjpAS5Gy0GFkchglsAA6wAA">
<XPD:ATTR name="Title" type="string">ParticleRenderer</XPD:ATTR>
<XPD:ATTR name="#OwnedElements" type="integer">1</XPD:ATTR>
<XPD:OBJ name="OwnedElements[0]" type="UMLModel" guid="fz9G1JBPSUSkW7llxgnQRQAA">
<XPD:ATTR name="Name" type="string">ParticleRenderer</XPD:ATTR>
<XPD:ATTR name="InnerName" type="string">ParticleRenderer</XPD:ATTR>
<XPD:REF name="Namespace">pPjpAS5Gy0GFkchglsAA6wAA</XPD:REF>
<XPD:ATTR name="#OwnedDiagrams" type="integer">1</XPD:ATTR>
<XPD:OBJ name="OwnedDiagrams[0]" type="UMLClassDiagram" guid="Q+AhfzwKP0KuhUYatGRclgAA">
<XPD:ATTR name="Name" type="string">ParticleRenderer</XPD:ATTR>
<XPD:REF name="DiagramOwner">fz9G1JBPSUSkW7llxgnQRQAA</XPD:REF>
<XPD:OBJ name="DiagramView" type="UMLClassDiagramView" guid="0+9K+aLOskqI42ILpjooAgAA">
<XPD:REF name="Diagram">Q+AhfzwKP0KuhUYatGRclgAA</XPD:REF>
<XPD:ATTR name="#OwnedViews" type="integer">15</XPD:ATTR>
<XPD:OBJ name="OwnedViews[0]" type="UMLNoteView" guid="MfpCy7v4AkCLSD6uhbHy4QAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Left" type="integer">1448</XPD:ATTR>
<XPD:ATTR name="Top" type="integer">400</XPD:ATTR>
<XPD:ATTR name="Width" type="integer">1058</XPD:ATTR>
<XPD:ATTR name="Height" type="integer">608</XPD:ATTR>
<XPD:ATTR name="Text" type="string">void ParticleRenderer::UVInfo::setMaterialUVTransform(const Vector2&amp; offset, float rotation, const Vector2&amp; repeat, Material* material, const String&amp; uName /*= &quot;UOffset&quot;*/, const String&amp; vName /*= &quot;VOffset&quot;*/)
{
        Matrix3x4 transform(Matrix3x4::IDENTITY);
        CoreUtil::toUVTransform(transform,
                offset, rotation, repeat);

        material-&gt;setShaderParameter(uName, Vector4(transform[0][0], transform[0][1], transform[0][2], transform[0][3]));
        material-&gt;setShaderParameter(vName, Vector4(transform[1][0], transform[1][1], transform[1][2], transform[1][3]));
}

void ParticleRenderer::UVInfo::setMaterialUVTransform(Material* material, const String&amp; uName /*= &quot;UOffset&quot;*/, const String&amp; vName /*= &quot;VOffset&quot;*/)
{
        setMaterialUVTransform(mUVOffset, mUVRotation, mUVRepeat, material, uName, vName);
}
void ParticleRenderer::UVInfo::setMaterialUVTransformWithAnim(Material* material, const String&amp; uName /*= &quot;UOffset&quot;*/, const String&amp; vName /*= &quot;VOffset&quot;*/)
{
        setMaterialUVTransform(mUVOffset + mUVAnimOffset, mUVRotation, mUVRepeat, material, uName, vName);
}
void ParticleRenderer::UVInfo::setGraphicsUVTransform(const Vector2&amp; offset, float rotation, const Vector2&amp; repeat, Graphics* graphics, const String&amp; uName /*= &quot;UOffset&quot;*/, const String&amp; vName /*= &quot;VOffset&quot;*/)
{
        Matrix3x4 transform(Matrix3x4::IDENTITY);
        CoreUtil::toUVTransform(transform,
                offset, rotation, repeat);

        graphics-&gt;setShaderParameter(uName, Vector4(transform[0][0], transform[0][1], transform[0][2], transform[0][3]));
        graphics-&gt;setShaderParameter(vName, Vector4(transform[1][0], transform[1][1], transform[1][2], transform[1][3]));
}

void ParticleRenderer::UVInfo::setGraphicsUVTransform(Graphics* graphics, const String&amp; uName /*= &quot;UOffset&quot;*/, const String&amp; vName /*= &quot;VOffset&quot;*/)
{
        setGraphicsUVTransform(mUVOffset, mUVRotation, mUVRepeat, graphics, uName, vName);
}
void ParticleRenderer::UVInfo::setGraphicsUVTransformWithAnim(Graphics* graphics, const String&amp; uName /*= &quot;UOffset&quot;*/, const String&amp; vName /*= &quot;VOffset&quot;*/)
{
        setGraphicsUVTransform(mUVOffset + mUVAnimOffset, mUVRotation, mUVRepeat, graphics, uName, vName);
}


// UVInfo 的主要作用有两个，一个是把 offset,rotation repeat 转换为一个矩阵，然后把矩阵的第一行和第二行分别赋值给 Material 的 &quot;UOffset&quot;  和 &quot;VOffset&quot; 属性
// 另一个作用是 把 mUAddressMode 和 mVAddressMode 赋值为 漫反射纹理 的寻址模式
</XPD:ATTR>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[1]" type="UMLNoteView" guid="Yw3AByvCjEqfVY/phqHwvwAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Left" type="integer">2888</XPD:ATTR>
<XPD:ATTR name="Top" type="integer">232</XPD:ATTR>
<XPD:ATTR name="Width" type="integer">586</XPD:ATTR>
<XPD:ATTR name="Height" type="integer">938</XPD:ATTR>
<XPD:ATTR name="Text" type="string">***************************************************
///漫反射uv信息
UVInfo                        mDiffuseUVInfo;
***************************************************
//更新材质
void ParticleRenderer::updateMaterial()
{
       ..................
        mDiffuseUVInfo.setMaterialUVTransform(mMaterial);
       ....................
}
// 根据  mDiffuseUVInfo 已经设置的属性，设置Material 的 &quot;UOffset&quot;  和 &quot;VOffset&quot; 属性

-----------------------------------------------------------------------------------------------------------------------
///更新纹理
void ParticleRenderer::updateTexture()
{
       ..............................
        if (mTexture)
        {
                ........................
                mTexture-&gt;setBorderColor(Color(0.0f, 0.0f, 0.0f, 0.0f));
                mTexture-&gt;setAddressMode(COORD_U, (TextureAddressMode)mDiffuseUVInfo.mUAddressMode);
                mTexture-&gt;setAddressMode(COORD_V, (TextureAddressMode)mDiffuseUVInfo.mVAddressMode);
        }
}

-----------------------------------------------------------------------------------------------------------------------
//设置寻址模式
void ParticleRenderer::setUAddressMode(unsigned mode)
{
        mDiffuseUVInfo.mUAddressMode = mode;
        if(mTexture)
                mTexture-&gt;setAddressMode(COORD_U, (TextureAddressMode)mDiffuseUVInfo.mUAddressMode);
}
void ParticleRenderer::setVAddressMode(unsigned mode)
{
        mDiffuseUVInfo.mVAddressMode = mode;
        if (mTexture)
                mTexture-&gt;setAddressMode(COORD_V, (TextureAddressMode)mDiffuseUVInfo.mVAddressMode);
}
// 用 mDiffuseUVInfo.mUAddressMode  mDiffuseUVInfo.mVAddressMode设置漫反射纹理的 UV寻址模式

----------------------------------------------------------------------------------------------------------------------------
//更新后
void ParticleRenderer::postUpdate(float timeElapsed)
{
                .............................
        if (mDiffuseUVInfo.mUVAnimEnabled)
        {
                float speed = mDynamicAttributeHelper.calculate(mDynDiffuseUVSpeed, timeFraction).getFloat();
                mDiffuseUVInfo.mUVAnimOffset += mDiffuseUVInfo.mUVAnimSpeed * timeElapsed * speed;
        }
                ..................................
        if (isUVAnimEnabled())
        {
                mDiffuseUVInfo.setMaterialUVTransformWithAnim(mMaterial);
        }
                .................................
}
// 在update函数过后，设置 mDiffuseUVInfo.mUVAnimOffset属性，并且更新mDiffuseUVInfo的矩阵
// 重新设置 Material 的 &quot;UOffset&quot;  和 &quot;VOffset&quot; 属性
</XPD:ATTR>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[2]" type="UMLNoteView" guid="g8mCwxnbsUC6G1kpZ3NTAgAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Left" type="integer">340</XPD:ATTR>
<XPD:ATTR name="Top" type="integer">428</XPD:ATTR>
<XPD:ATTR name="Width" type="integer">834</XPD:ATTR>
<XPD:ATTR name="Height" type="integer">548</XPD:ATTR>
<XPD:ATTR name="Text" type="string">struct UVInfo
{
        ///uv动画
        bool                  mUVAnimEnabled;
        Vector2             mUVAnimOffset;
        Vector2             mUVAnimSpeed;
        ///uv变换
        Vector2             mUVOffset;
        float                  mUVRotation;
        Vector2             mUVRepeat;
        ///寻址模式
        unsigned            mUAddressMode;
        unsigned            mVAddressMode;
}


  &lt;Group name=&quot;漫反射纹理&quot;&gt;
    &lt;Property name=&quot;资源&quot; data=&quot;effect/unpack;false&quot; desc=&quot;&quot; vType=&quot;Texture&quot; propertyID=&quot;tex_name&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;U寻址&quot; data=&quot;平铺;镜像;限制;单张;&quot; desc=&quot;&quot; vType=&quot;Enum&quot; propertyID=&quot;u_address_mode&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;V寻址&quot; data=&quot;平铺;镜像;限制;单张;&quot; desc=&quot;&quot; vType=&quot;Enum&quot; propertyID=&quot;v_address_mode&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;偏移&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;Vector2&quot; propertyID=&quot;uv_offset&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;旋转&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;Double&quot; propertyID=&quot;uv_rotation&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;平铺&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;Vector2&quot; propertyID=&quot;uv_repeat&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;动画启用&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;Bool&quot; propertyID=&quot;uv_anim_enabled&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;动画方向&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;Vector2&quot; propertyID=&quot;uv_anim_speed&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;动画速度&quot; data=&quot;0;10;Float&quot; desc=&quot;&quot; vType=&quot;DynamicAttribute&quot; propertyID=&quot;uv_anim_global_speed&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
  &lt;/Group&gt;
</XPD:ATTR>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[3]" type="UMLNoteLinkView" guid="v92E0qgnL0mr8Ydkhl8P2gAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Points" type="Points">1448,702;1173,702</XPD:ATTR>
<XPD:REF name="Head">g8mCwxnbsUC6G1kpZ3NTAgAA</XPD:REF>
<XPD:REF name="Tail">MfpCy7v4AkCLSD6uhbHy4QAA</XPD:REF>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[4]" type="UMLNoteLinkView" guid="kiqFrS/9qUODcQse1MM3zAAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Points" type="Points">2888,701;2505,702</XPD:ATTR>
<XPD:REF name="Head">MfpCy7v4AkCLSD6uhbHy4QAA</XPD:REF>
<XPD:REF name="Tail">Yw3AByvCjEqfVY/phqHwvwAA</XPD:REF>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[5]" type="UMLNoteView" guid="Jb4qIv1y3Ui/ZAP1pD7jjQAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Left" type="integer">2876</XPD:ATTR>
<XPD:ATTR name="Top" type="integer">1316</XPD:ATTR>
<XPD:ATTR name="Width" type="integer">658</XPD:ATTR>
<XPD:ATTR name="Height" type="integer">1733</XPD:ATTR>
<XPD:ATTR name="Text" type="string">*************************************************
///多层溶解
Vector&lt;DissolveInfo&gt;        mDissolveInfos;
ColorLine                             mDissolveColor;
float                                    mDissolveColorSize;
UVInfo                                 mDissolveUVInfo;
*************************************************
//更新材质
void ParticleRenderer::updateMaterial()
{
       ........................
        if (isDissolveEnabled(0))
        {
                mDissolveUVInfo.setMaterialUVTransform(mMaterial, DISSOLVE_UNAME, DISSOLVE_VNAME);
        }
        ........................
}
// 根据  mDissolveUVInfo 已经设置的属性，设置Material 的 &quot;DissolveUOffset&quot;  和 &quot;DissolveVOffset&quot; 属性

---------------------------------------------------------------------------------------------------------------------------------

void ParticleRenderer::_notifyStart(void)
{

        Vector&lt;DissolveInfo&gt;::Iterator i, iend = mDissolveInfos.end();
        for (i = mDissolveInfos.begin(); i != iend; ++i)
        {
                DissolveInfo&amp; info = *i;
                if (info.textureDirty &amp;&amp; info.enabled)
                {
                        ResourceCache* cache = mContext-&gt;getSubsystem&lt;ResourceCache&gt;();
                        if (!info.textureName.empty())
                                info.texture = cache-&gt;getResource&lt;Texture2D&gt;(info.textureName, true, Texture::CLOSE_MINMAP_PARAMS);
                        if (info.texture)
                        {
                                info.texture-&gt;setBorderColor(Color(0.0f, 0.0f, 0.0f, 0.0f));
                                info.texture-&gt;setAddressMode(COORD_U, (TextureAddressMode)mDissolveUVInfo.mUAddressMode);
                                info.texture-&gt;setAddressMode(COORD_V, (TextureAddressMode)mDissolveUVInfo.mVAddressMode);
                        }
                        info.textureDirty = false;
                }
        }
}
// 用 mDissolveUVInfo.mUAddressMode  mDissolveUVInfo.mVAddressMode设置DissolveInfo相关纹理的 UV寻址模式

------------------------------------------------------------------------------------------------------------------------------------------

void ParticleRenderer::postUpdate(float timeElapsed)
{
        float timeFraction = getTimeFraction();

        if (isDissolveUVAnimEnabled())
        {
                mDissolveUVInfo.mUVAnimOffset += mDissolveUVInfo.mUVAnimSpeed * timeElapsed;
        }

        if (isDissolveEnabled(0) &amp;&amp; mFirstTotalTimeToLiveSet)
        {
                //更新shader参数
                for (unsigned index = 0; index &lt; mDissolveInfos.size(); ++index)
                {
                        DissolveInfo&amp; info = mDissolveInfos[index];
                        float DissolveFactor = mDynamicAttributeHelper.calculate(info.time, timeFraction).getFloat();
                        mMaterial-&gt;setShaderParameter(DISSOLVE_FACTOR[index], DissolveFactor);
                }
                Color DissolveColor = mDissolveColor._calculate(timeFraction);
                mMaterial-&gt;setShaderParameter(&quot;DissolveColor&quot;, DissolveColor);
                mMaterial-&gt;setShaderParameter(&quot;DissolveColorSize&quot;, mDissolveColorSize);
        }

        if (isDissolveUVAnimEnabled())
        {
                mDissolveUVInfo.setMaterialUVTransformWithAnim(mMaterial, DISSOLVE_UNAME, DISSOLVE_VNAME);
        }
}

// 设置  mDissolveUVInfo.mUVAnimOffset
// 使用  DissolveInfo.time 计算出一个系数，设置  Material 的 &quot;DissolveFactor0&quot;  和 ”DissolveFactor1“属性
// 根据  mDissolveUVInfo 已经设置的属性,更新矩阵，设置Material 的 &quot;DissolveUOffset&quot;  和 &quot;DissolveVOffset&quot; 属性
------------------------------------------------------------------------------------------------------------------------------------------

///设置寻址模式
void ParticleRenderer::setDissolveUAddressMode(unsigned mode)
{
        mDissolveUVInfo.mUAddressMode = mode;
        for (unsigned index = 0; index &lt; mDissolveInfos.size(); ++index)
        {
                DissolveInfo&amp; info = mDissolveInfos[index];
                if(info.enabled &amp;&amp; info.texture)
                        info.texture-&gt;setAddressMode(COORD_U, (TextureAddressMode)mDissolveUVInfo.mUAddressMode);
        }
}

void ParticleRenderer::setDissolveVAddressMode(unsigned mode)
{
        mDissolveUVInfo.mVAddressMode = mode;
        for (unsigned index = 0; index &lt; mDissolveInfos.size(); ++index)
        {
                DissolveInfo&amp; info = mDissolveInfos[index];
                if (info.enabled &amp;&amp; info.texture)
                        info.texture-&gt;setAddressMode(COORD_V, (TextureAddressMode)mDissolveUVInfo.mVAddressMode);
        }
}
// 用 mDissolveUVInfo.mUAddressMode  mDissolveUVInfo.mVAddressMode设置DissolveInfo相关纹理的 UV寻址模式
----------------------------------------------------------------------------------------------------------------------------------------------
///绑定所有溶解纹理
void ParticleRenderer::bindAllDissolveTexture(Material* mat)
{
        if (isDissolveEnabled(0))
                mat-&gt;setTexture(TU_ENVIRONMENT, getDissolveTexture(0));
        if (isDissolveEnabled(1))
                mat-&gt;setTexture(TU_DISSOLVE, getDissolveTexture(1));
}
//  mDissolveUVInfo 的大部分属性最终作用于  mDissolveInfos中的两个纹理，当启用溶解的时候， mDissolveInfos中的纹理
//  会被设置为Material 的 TU_ENVIRONMENT 和 TU_DISSOLVE 级纹理
</XPD:ATTR>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[6]" type="UMLNoteView" guid="094zBomoJ0Wlk+btXAEHOwAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Left" type="integer">372</XPD:ATTR>
<XPD:ATTR name="Top" type="integer">1852</XPD:ATTR>
<XPD:ATTR name="Width" type="integer">839</XPD:ATTR>
<XPD:ATTR name="Height" type="integer">653</XPD:ATTR>
<XPD:ATTR name="Text" type="string">struct UVInfo
{
        ///uv动画
        bool                  mUVAnimEnabled;
        Vector2             mUVAnimOffset;
        Vector2             mUVAnimSpeed;
        ///uv变换
        Vector2             mUVOffset;
        float                  mUVRotation;
        Vector2             mUVRepeat;
        ///寻址模式
        unsigned            mUAddressMode;
        unsigned            mVAddressMode;
}

///溶解结构
struct DissolveInfo
{
        bool                                        enabled;
        SharedPtr&lt;DynamicAttribute&gt;        time;
        String                                        textureName;
        SharedPtr&lt;Texture2D&gt;        texture;
        bool                                        textureDirty;
};

&lt;Group name=&quot;溶解配置&quot;&gt;
    &lt;Property name=&quot;燃烧颜色&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;TimeColor&quot; propertyID=&quot;dissolve_color&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;燃烧颜色宽度&quot; data=&quot;0;0.2;Float&quot; desc=&quot;&quot; vType=&quot;Double&quot; propertyID=&quot;dissolve_color_size&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;U寻址&quot; data=&quot;平铺;镜像;限制;单张;&quot; desc=&quot;&quot; vType=&quot;Enum&quot; propertyID=&quot;dissolve_u_address_mode&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;V寻址&quot; data=&quot;平铺;镜像;限制;单张;&quot; desc=&quot;&quot; vType=&quot;Enum&quot; propertyID=&quot;dissolve_v_address_mode&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;偏移&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;Vector2&quot; propertyID=&quot;dissolve_uv_offset&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;旋转&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;Double&quot; propertyID=&quot;dissolve_uv_rotation&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;平铺&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;Vector2&quot; propertyID=&quot;dissolve_uv_repeat&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;动画启用&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;Bool&quot; propertyID=&quot;dissolve_uv_anim_enabled&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;动画速度&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;Vector2&quot; propertyID=&quot;dissolve_uv_anim_speed&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
  &lt;/Group&gt;

&lt;Group name=&quot;溶解纹理&quot;&gt;
    &lt;Property name=&quot;溶解1&quot; data=&quot;0;10;Float&quot; desc=&quot;&quot; vType=&quot;DynamicAttribute&quot; propertyID=&quot;dissolve&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;溶解资源1&quot; data=&quot;effect/unpack&quot; desc=&quot;&quot; vType=&quot;Texture&quot; propertyID=&quot;dissolve_tex_name&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;溶解2&quot; data=&quot;0;10;Float&quot; desc=&quot;&quot; vType=&quot;DynamicAttribute&quot; propertyID=&quot;dissolve2&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;溶解资源2&quot; data=&quot;effect/unpack&quot; desc=&quot;&quot; vType=&quot;Texture&quot; propertyID=&quot;dissolve2_tex_name&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
  &lt;/Group&gt;
</XPD:ATTR>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[7]" type="UMLNoteView" guid="I/tRW6oXO0aIK/GAAzbDYQAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Left" type="integer">1476</XPD:ATTR>
<XPD:ATTR name="Top" type="integer">1880</XPD:ATTR>
<XPD:ATTR name="Width" type="integer">1058</XPD:ATTR>
<XPD:ATTR name="Height" type="integer">608</XPD:ATTR>
<XPD:ATTR name="Text" type="string">void ParticleRenderer::UVInfo::setMaterialUVTransform(const Vector2&amp; offset, float rotation, const Vector2&amp; repeat, Material* material, const String&amp; uName /*= &quot;UOffset&quot;*/, const String&amp; vName /*= &quot;VOffset&quot;*/)
{
        Matrix3x4 transform(Matrix3x4::IDENTITY);
        CoreUtil::toUVTransform(transform,
                offset, rotation, repeat);

        material-&gt;setShaderParameter(uName, Vector4(transform[0][0], transform[0][1], transform[0][2], transform[0][3]));
        material-&gt;setShaderParameter(vName, Vector4(transform[1][0], transform[1][1], transform[1][2], transform[1][3]));
}

void ParticleRenderer::UVInfo::setMaterialUVTransform(Material* material, const String&amp; uName /*= &quot;UOffset&quot;*/, const String&amp; vName /*= &quot;VOffset&quot;*/)
{
        setMaterialUVTransform(mUVOffset, mUVRotation, mUVRepeat, material, uName, vName);
}
void ParticleRenderer::UVInfo::setMaterialUVTransformWithAnim(Material* material, const String&amp; uName /*= &quot;UOffset&quot;*/, const String&amp; vName /*= &quot;VOffset&quot;*/)
{
        setMaterialUVTransform(mUVOffset + mUVAnimOffset, mUVRotation, mUVRepeat, material, uName, vName);
}
void ParticleRenderer::UVInfo::setGraphicsUVTransform(const Vector2&amp; offset, float rotation, const Vector2&amp; repeat, Graphics* graphics, const String&amp; uName /*= &quot;UOffset&quot;*/, const String&amp; vName /*= &quot;VOffset&quot;*/)
{
        Matrix3x4 transform(Matrix3x4::IDENTITY);
        CoreUtil::toUVTransform(transform,
                offset, rotation, repeat);

        graphics-&gt;setShaderParameter(uName, Vector4(transform[0][0], transform[0][1], transform[0][2], transform[0][3]));
        graphics-&gt;setShaderParameter(vName, Vector4(transform[1][0], transform[1][1], transform[1][2], transform[1][3]));
}

void ParticleRenderer::UVInfo::setGraphicsUVTransform(Graphics* graphics, const String&amp; uName /*= &quot;UOffset&quot;*/, const String&amp; vName /*= &quot;VOffset&quot;*/)
{
        setGraphicsUVTransform(mUVOffset, mUVRotation, mUVRepeat, graphics, uName, vName);
}
void ParticleRenderer::UVInfo::setGraphicsUVTransformWithAnim(Graphics* graphics, const String&amp; uName /*= &quot;UOffset&quot;*/, const String&amp; vName /*= &quot;VOffset&quot;*/)
{
        setGraphicsUVTransform(mUVOffset + mUVAnimOffset, mUVRotation, mUVRepeat, graphics, uName, vName);
}


// UVInfo 的主要作用有两个，一个是把 offset,rotation repeat 转换为一个矩阵，然后把矩阵的第一行和第二行分别赋值给 Material 的 &quot;UOffset&quot;  和 &quot;VOffset&quot; 属性
// 另一个作用是 把 mUAddressMode 和 mVAddressMode 赋值为 漫反射纹理 的寻址模式
</XPD:ATTR>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[8]" type="UMLNoteLinkView" guid="Y7pMoyyjSEOKfoJfaYIUVQAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Points" type="Points">1476,2181;1210,2180</XPD:ATTR>
<XPD:REF name="Head">094zBomoJ0Wlk+btXAEHOwAA</XPD:REF>
<XPD:REF name="Tail">I/tRW6oXO0aIK/GAAzbDYQAA</XPD:REF>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[9]" type="UMLNoteLinkView" guid="CmPTIMnZS0icKsOpXayuoAAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Points" type="Points">2876,2182;2533,2182</XPD:ATTR>
<XPD:REF name="Head">I/tRW6oXO0aIK/GAAzbDYQAA</XPD:REF>
<XPD:REF name="Tail">Jb4qIv1y3Ui/ZAP1pD7jjQAA</XPD:REF>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[10]" type="UMLNoteView" guid="G1SJiuDXmEqCF9xSzj6MJwAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Left" type="integer">440</XPD:ATTR>
<XPD:ATTR name="Top" type="integer">3848</XPD:ATTR>
<XPD:ATTR name="Width" type="integer">822</XPD:ATTR>
<XPD:ATTR name="Height" type="integer">548</XPD:ATTR>
<XPD:ATTR name="Text" type="string">///纹理动画类型
enum TextureAnimationType
{
        TAT_LOOP,
        TAT_UP_DOWN,
        TAT_RANDOM,
        TAT_ONCE,
};

///纹理动画结构
struct LYEFFECT_API TextureAnimation
{
        bool enabled;
        float animationTimeStep;
        float animationTimeStepCount;
        bool startRandom;
        uint16 randomStart;
        uint16 randomEnd;
        bool nextIndex;
        unsigned type;
        uint16 textureCoordsStart;
        uint16 textureCoordsEnd;
        void _determineNextTextureCoords(ParticleRenderer* renderer, uint16&amp; textureCoordsCurrent, bool&amp; textureAnimationDirectionUp);
};


  &lt;Group name=&quot;逐帧动画&quot;&gt;
    &lt;Property name=&quot;启用&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;Bool&quot; propertyID=&quot;texture_animation_enabled&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;类型&quot; data=&quot;循环;上下;随机;单次;&quot; desc=&quot;&quot; vType=&quot;Enum&quot; propertyID=&quot;texture_animation_type&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;时间步进&quot; data=&quot;4&quot; desc=&quot;&quot; vType=&quot;Double&quot; propertyID=&quot;texture_animation_time_step&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;开始随机&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;Bool&quot; propertyID=&quot;texture_animation_start_random&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;随机开始帧&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;Int&quot; propertyID=&quot;texture_animation_random_start&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;随机结束帧&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;Int&quot; propertyID=&quot;texture_animation_random_end&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;切割行&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;Int&quot; propertyID=&quot;tex_split_row&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
    &lt;Property name=&quot;切割列&quot; data=&quot;&quot; desc=&quot;&quot; vType=&quot;Int&quot; propertyID=&quot;tex_split_col&quot; enable=&quot;true&quot; muledit=&quot;true&quot;&gt;&lt;/Property&gt;
  &lt;/Group&gt;
</XPD:ATTR>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[11]" type="UMLNoteView" guid="wQzLuSWXu0qCa1rgrzGY4wAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Left" type="integer">1656</XPD:ATTR>
<XPD:ATTR name="Top" type="integer">3664</XPD:ATTR>
<XPD:ATTR name="Width" type="integer">841</XPD:ATTR>
<XPD:ATTR name="Height" type="integer">908</XPD:ATTR>
<XPD:ATTR name="Text" type="string">void ParticleRenderer::TextureAnimation::_determineNextTextureCoords(ParticleRenderer* renderer, uint16&amp; textureCoordsCurrent, bool&amp; textureAnimationDirectionUp)
{
        switch (type)
        {
        case TAT_LOOP:
        {
                if (textureCoordsCurrent &gt;= textureCoordsEnd)
                {
                        textureCoordsCurrent = textureCoordsStart;
                }
                else
                {
                        (textureCoordsCurrent)++;
                }
        }
        break;
        case TAT_ONCE:
        {
                (textureCoordsCurrent)++;
        }
        break;

        case TAT_UP_DOWN:
        {
                if (textureAnimationDirectionUp == true)
                {
                        if (textureCoordsCurrent &gt;= textureCoordsEnd)
                        {
                                (textureCoordsCurrent)--;
                                textureAnimationDirectionUp = false;
                        }
                        else
                        {
                                (textureCoordsCurrent)++;
                        }
                }
                else
                {
                        if (textureCoordsCurrent &lt;= textureCoordsStart)
                        {
                                (textureCoordsCurrent)++;
                                textureAnimationDirectionUp = true;
                        }
                        else
                        {
                                (textureCoordsCurrent)--;
                        }
                }
        }
        break;

        case TAT_RANDOM:
        {
                textureCoordsCurrent = (uint16)renderer-&gt;getParticleSystem()-&gt;getRangeRandom((float)textureCoordsStart, (float)textureCoordsEnd + 0.999f);
        }
        break;
        }
}

// 根据type类型，计算textureCoordsCurrent
</XPD:ATTR>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[12]" type="UMLNoteLinkView" guid="fit1z6OwgEaqZw4BebJRhAAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Points" type="Points">1656,4118;1261,4119</XPD:ATTR>
<XPD:REF name="Head">G1SJiuDXmEqCF9xSzj6MJwAA</XPD:REF>
<XPD:REF name="Tail">wQzLuSWXu0qCa1rgrzGY4wAA</XPD:REF>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[13]" type="UMLNoteView" guid="KMTF/z2CpUye8nHCuTwv5wAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Left" type="integer">2724</XPD:ATTR>
<XPD:ATTR name="Top" type="integer">3520</XPD:ATTR>
<XPD:ATTR name="Width" type="integer">756</XPD:ATTR>
<XPD:ATTR name="Height" type="integer">1193</XPD:ATTR>
<XPD:ATTR name="Text" type="string">******************************************************
TextureAnimation        mTextureAnimation;
******************************************************
void ParticleRenderer::_notifyStart(void)
{
        ......................................
        //初始化序列帧动画值
        if (mTextureAnimation.enabled)
        {
                mTextureAnimation.textureCoordsStart = 0;
                mTextureAnimation.textureCoordsEnd = getNumImagesets() - 1;
        }
}
// 初始化的时候 设置  mTextureAnimation.textureCoordsStart 和  mTextureAnimation.textureCoordsEnd
--------------------------------------------------------------------------------------------------------------------------------------------

//更新序列动画
void ParticleRenderer::updateTextureAnimation(Particle* particle)
{
        //更新序列动画
        if (mTextureAnimation.enabled &amp;&amp; particle-&gt;particleType == Particle::PT_VISUAL)
        {
                ParticleVisual* visualParticle = static_cast&lt;ParticleVisual*&gt;(particle);

                if (mTextureAnimation.nextIndex)
                {
                        mTextureAnimation._determineNextTextureCoords(this, visualParticle-&gt;textureCoordsCurrent,
                                visualParticle-&gt;textureAnimationDirectionUp);
                }
        }
}
// 如果 mTextureAnimation.nextIndex 为 true 。计算 mTextureAnimation.textureCoordsCurrent
--------------------------------------------------------------------------------------------------------------------------------------------

//准备处理粒子
void ParticleRenderer::_preProcessParticles(ParticleTechnique* particleTechnique, float timeElapsed)
{
        if (mTextureAnimation.enabled)
        {
                mTextureAnimation.nextIndex = false;
                mTextureAnimation.animationTimeStepCount += timeElapsed;
                if (mTextureAnimation.animationTimeStepCount &gt; mTextureAnimation.animationTimeStep)
                {
                        mTextureAnimation.animationTimeStepCount -= mTextureAnimation.animationTimeStep;
                        mTextureAnimation.nextIndex = true;
                }
        }
}
// 确定   mTextureAnimation.animationTimeStepCount  和  mTextureAnimation.nextIndex，为 updateTextureAnimation作准备
--------------------------------------------------------------------------------------------------------------------------------------------

//发射时
void ParticleRenderer::_initParticleForEmission(Particle* particle)
{
        if (particle-&gt;particleType == Particle::PT_VISUAL &amp;&amp; mTextureAnimation.enabled)
        {
                ParticleVisual* visualParticle = static_cast&lt;ParticleVisual*&gt;(particle);

                if (mTextureAnimation.startRandom)
                {
                        uint16 randomStart = mTextureAnimation.randomStart;
                        uint16 randomEnd = mTextureAnimation.randomEnd;

                        if (randomStart &lt; mTextureAnimation.textureCoordsStart)
                                randomStart = mTextureAnimation.textureCoordsStart;
                        if (randomEnd == 0 || randomEnd &gt; mTextureAnimation.textureCoordsEnd)
                                randomEnd = mTextureAnimation.textureCoordsEnd;
                        if (randomEnd &lt; randomStart)
                                randomEnd = randomStart;

                        visualParticle-&gt;textureCoordsCurrent = (uint16)getParticleSystem()-&gt;getRangeRandom((float)randomStart, (float)randomEnd + 0.999f);
                }
                else
                {
                        visualParticle-&gt;textureCoordsCurrent = mTextureAnimation.textureCoordsStart;
                }
        }
}
//  初始化   visualParticle-&gt;textureCoordsCurrent
</XPD:ATTR>
</XPD:OBJ>
<XPD:OBJ name="OwnedViews[14]" type="UMLNoteLinkView" guid="F9BEo7Qvj0CW51MDT1SU2wAA">
<XPD:ATTR name="LineColor" type="string">clMaroon</XPD:ATTR>
<XPD:ATTR name="FillColor" type="string">$00B9FFFF</XPD:ATTR>
<XPD:ATTR name="Points" type="Points">2724,4116;2496,4116</XPD:ATTR>
<XPD:REF name="Head">wQzLuSWXu0qCa1rgrzGY4wAA</XPD:REF>
<XPD:REF name="Tail">KMTF/z2CpUye8nHCuTwv5wAA</XPD:REF>
</XPD:OBJ>
</XPD:OBJ>
</XPD:OBJ>
</XPD:OBJ>
</XPD:OBJ>
</XPD:BODY>
</XPD:PROJECT>
